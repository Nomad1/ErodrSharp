/*
 * Image.cs
 * 
 * Helper class for PGM reading and writing
 * Ported from https://github.com/henrikglass/erodr/blob/master/src/io.c
 * 
 * Created by Claude Sonnet 3.5 under supervision by Nomad1
 */

using System.Text;

namespace ErodrSharp
{
    public class Image
    {
        public readonly float[] Buffer;
        public readonly int Width;
        public readonly int Height;

        private const int PRECISION_8 = 255;
        private const int PRECISION_16 = 65535;

        public Image(int width, int height, float[] buffer)
        {
            Width = width;
            Height = height;
            Buffer = buffer;
        }

        public Image(string filepath)
        {
            using (var reader = new BinaryReader(File.Open(filepath, FileMode.Open)))
            {
                // Read header
                string magic = ReadNextValue(reader);
                Width = int.Parse(ReadNextValue(reader));
                Height = int.Parse(ReadNextValue(reader));
                int precision = int.Parse(ReadNextValue(reader));

                Buffer = new float[Width * Height];

                if (magic == "P2") // ASCII
                {
                    for (int i = 0; i < Width * Height; i++)
                    {
                        Buffer[i] = float.Parse(ReadNextValue(reader)) / precision;
                    }
                }
                else if (magic == "P5") // Binary
                {
                    int byteDepth = precision <= PRECISION_8 ? 1 : 2;
                    for (int i = 0; i < Width * Height; i++)
                    {
                        int val;
                        if (byteDepth == 2)
                        {
                            val = (reader.ReadByte() << 8) | reader.ReadByte();
                        }
                        else
                        {
                            val = reader.ReadByte();
                        }
                        Buffer[i] = (float)val / precision;
                    }
                }
                else
                {
                    throw new FormatException("Unsupported PGM format");
                }
            }
        }

        public void Save(string filepath, bool asciiEncoding)
        {
            using (var writer = new StreamWriter(filepath))
            {
                // Write header
                writer.WriteLine(asciiEncoding ? "P2" : "P5");
                writer.WriteLine("# Generated by HydraulicErosion");
                writer.WriteLine($"{Width} {Height}");
                writer.WriteLine(PRECISION_16.ToString());

                if (asciiEncoding)
                {
                    for (int i = 0; i < Width * Height; i++)
                    {
                        writer.WriteLine(((int)Math.Round(Buffer[i] * PRECISION_16)).ToString());
                    }
                }
                else
                {
                    writer.Flush();
                    using (var binaryWriter = new BinaryWriter(writer.BaseStream, Encoding.ASCII, true))
                    {
                        for (int i = 0; i < Width * Height; i++)
                        {
                            ushort gv = (ushort)Math.Round(Buffer[i] * PRECISION_16);
                            binaryWriter.Write((byte)((gv >> 8) & 0xFF));
                            binaryWriter.Write((byte)(gv & 0xFF));
                        }
                    }
                }
            }
        }

        private string ReadNextValue(BinaryReader reader)
        {
            var sb = new StringBuilder();
            int c;
            bool inComment = false;

            while ((c = reader.Read()) != -1)
            {
                char ch = (char)c;

                if (inComment)
                {
                    if (ch == '\n')
                        inComment = false;
                    continue;
                }

                if (char.IsWhiteSpace(ch))
                {
                    if (sb.Length > 0)
                        break;
                    continue;
                }

                if (ch == '#')
                {
                    inComment = true;
                    continue;
                }

                sb.Append(ch);
            }

            return sb.ToString();
        }
    }

}